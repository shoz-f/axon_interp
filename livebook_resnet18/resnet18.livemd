# ResNet18 image classification

```elixir
File.cd!(__DIR__)
# for windows JP
# System.shell("chcp 65001")

Mix.install(
  [
    {:nx, "~> 0.4.0"},
    {:exla, "~> 0.4.0"},
    {:cimg, "~> 0.1.13"},
    {:axon_interp, github: "shoz-f/axon_interp"},
    {:kino, "~> 0.7.0"}
  ],
  config: [
    nx: [default_defn_options: [compiler: EXLA]]
  ]
  # system_env: [{"NNINTERP", "Axon"}]
)
```

## 0.Original work

torchvision.models.resnet18 -  pre-trained model included in Pytorch.

* https://pytorch.org/vision/main/models/generated/torchvision.models.resnet18.html

***Thanks a lot!!!***

---

## Implementation with AxonInterp in Elixir

## 1.Defining the inference module: ResNet18

* Model<br>
  resnet18.axon: get from "https://github.com/shoz-f/axon_interp/releases/download/0.0.1/resnet18.axon" if not existed.

* Pre-processing<br>
  Resize the input image to the size `{@width, @height}` and gaussian normalize.

* Post-processing<br>
  Sort outputs and take first item.

```elixir
# download "imagenet1000.label" if not exists.
unless File.exists?("./imagenet1000.label") do
  AxonInterp.Util.download(
    "https://github.com/shoz-f/axon_interp/releases/download/0.0.1/imagenet1000.label"
  )
end
```

```elixir
defmodule ResNet18 do
  @width 224
  @height 224

  use AxonInterp,
    model: "./data/resnet18.axon",
    url: "https://github.com/shoz-f/axon_interp/releases/download/0.0.1/resnet18.axon",
    inputs: [f32: {1, 3, @height, @width}],
    outputs: [f32: {1, 1000}]

  @imagenet1000 (for item <- File.stream!("./imagenet1000.label") do
                   String.trim_trailing(item)
                 end)
                |> Enum.with_index(&{&2, &1})
                |> Enum.into(%{})

  def apply(img, top \\ 1) do
    # preprocess
    input0 =
      CImg.builder(img)
      |> CImg.resize({@width, @height})
      # mean=[0.485, 0.456, 0.406] and std=[0.229, 0.224, 0.225].
      |> CImg.to_binary([{:gauss, {{123.7, 58.4}, {116.3, 57.1}, {103.5, 57.4}}}, :nchw])

    # prediction
    outputs =
      session()
      |> AxonInterp.set_input_tensor(0, input0)
      |> AxonInterp.invoke()
      |> AxonInterp.get_output_tensor(0)
      |> Nx.from_binary(:f32)
      |> Nx.reshape({1000})

    # postprocess
    exp = Nx.exp(outputs)

    Nx.divide(exp, Nx.sum(exp))
    |> Nx.argsort(direction: :desc)
    |> Nx.slice([0], [top])
    |> Nx.to_flat_list()
    |> Enum.map(&@imagenet1000[&1])
  end
end
```

Launch `ResNet18`.

```elixir
AxonInterp.stop(ResNet18)
```

```elixir
ResNet18.start_link([])
```

Display the properties of the `ResNet18` model.

```elixir
AxonInterp.info(ResNet18)
```

## 2.Let's try it

Load a photo and apply ResNet18 to it.

```elixir
unless File.exists?("./lion.jpg"),
  do:
    AxonInterp.Util.download(
      "https://github.com/shoz-f/axon_interp/releases/download/0.0.1/lion.jpg"
    )

img = CImg.load("lion.jpg")
Kino.render(CImg.display_kino(img, :jpeg))

ResNet18.apply(img, 3)
```

## 3.TIL ;-)

## 4.Appendix - How to convert Pytorch model to Axon

#### STEP1.

Create Onnx model from torchvision.models.resnet18.

`mk_resnet18_onnx.py`

```python
import os
import torch
import torchvision.models as models

model = models.resnet18(weights='DEFAULT')
model.eval()

dummy_input = torch.randn(1, 3, 224, 224)

os.makedirs("data", exist_ok=True)
torch.onnx.export(model,
   dummy_input,
   "data/resnet18.onnx",
   verbose=False,
   input_names=["input.0"],
   output_names=["output.0"],
   export_params=True
   )
```

#### STEP2.

Convert Onnx model to Axon's graph and parameter.

`mk_resnet18_axon.exs`

<!-- livebook:{"force_markdown":true} -->

```elixir
Mix.install([
  {:axon_onnx, "~> 0.3.0"}
])

AxonOnnx.import("data/resnet18.onnx")
|> then(fn {model, params} -> Axon.serialize(model, params) end)
|> (&File.write("data/resnet18.axon", &1)).()

```

<!-- livebook:{"break_markdown":true} -->

&#9633;
